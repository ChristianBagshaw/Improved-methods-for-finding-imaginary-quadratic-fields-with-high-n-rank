# Algorithm 3.2 Improved Alg

# Suitable for smaller computations (one node, no sieving). 

# TO TEST/ RUN:
    # View bottom of file for instructions


# Algorithm 3.2 uses two slightly different ideas, depending on whether p=3 or p > 3. 
    # By default, the code below picks the correct/optimal algorithm for a given value of p, but there is a flag provided 
    # to allow p=3 to run the other branch (perform explicit ideal independence testing). This will produce more 
    # discriminants, but is not worth the increase in run-time. 
    
# This file serves to isolate and simply present Algorithm 3.2, but memory will quickly become an issue if this code 
    # is run verbatim for a large computation, since a lot of data is being stored in dictionaries. 
    # In a large computation, this data should be stored outside of memory, as demonstrated in the folder "How to implement"
  

# Input
    # An odd prime: "p"
    # Set of integer pairs {(lambda_i1, lambda_i2): "lambdas"
    # Lower bound on m_1: "lower_m1"
    # Upper bound on m_1: "upper_m1"
    # An optional flag, either True or False, which can force p=3 to perform explicit ideal independence testing
        # if set to true: "force_3" 
#Output
    # A list, "D", consisting of discriminants, each corresponding to a non-empty set of triples 
        # {(m_i, y_i, (lambda_ij)*z_i)} satisfying Proposition (2.3) (a) for n=p with 
        # lower_m1 <= m_1 <= upper_m1 and 2 <= m_2 < m_1, such that the ideal classes corresponding to the triples 
        # {(m_i, y_i, (lambda_ij)z_i)} generate a subgroup of the ideal class group of 
        # Q(sqrt{delta}) isomorphic to (Z/pZ)^k for some k > 1. 

    
        

from math import sqrt
import itertools
import numpy 
       
    
def Alg_3_2(p, lambdas, lower_m1, upper_m1, force_3=False):
    print("Running Algorithm 3.2 for")
    print("p="+str(p)+", lambdas = "+str(lambdas)+", lower_m1 = "+str(lower_m1)+", upper_m1 = "+str(upper_m1))
    
    if p ==3 and not force_3: 
        print("  Searching for solutions/ generating ideals...")
        ideals = {}

        for (lambda1, lambda2) in lambdas:
            for m1 in range(lower_m1, upper_m1 + 1):

                for m2 in range(2, m1):

                    N = 4*lambda2^2*m1^3 - 4*lambda1^2*m2^3
                    if N <= 0:
                        continue 
                    sqN = sqrt(N)
                    for a in divisors(N):
                        if a <= sqN:
                            b = N/a
                            if (2*lambda2).divides(a+b):

                                y1 = (a+b)/(2*lambda2)

                                t = y1^2 - 4*m1^3
                                if t < 0:
                                    delta = t.squarefree_part()
                                    if delta % 4 != 1:
                                          delta = 4*delta
                                    if delta.divides(t):
                                          z1 = int(sqrt(t/delta))
                                          c1 = gcd(m1,z1)
                                          if c1.divides(delta) and not 4.divides(c1):
                                              if m1 < sqrt(-delta/4):
                                                  if delta in ideals:
                                                      ideals[delta].append(m1)
                                                  else:
                                                      ideals[delta] = [m1]



                            if (2*lambda1).divides(a-b):
                                y2 = (a-b)/(2*lambda1)

                                t = y2^2 - 4*m2^3
                                if t < 0:
                                    delta = t.squarefree_part()
                                    if delta % 4 != 1:
                                          delta = 4*delta
                                    if delta.divides(t):
                                          z2 = int(sqrt(t/delta))
                                          c2 = gcd(m2,z2)
                                          if c2.divides(delta) and not 4.divides(c2):
                                              if m2 < sqrt(-delta/4):
                                                  if delta in ideals:
                                                      ideals[delta].append(m2)
                                                  else:
                                                      ideals[delta] = [m2]






        print("    Done!")


        # the following carries out lines 27-29 in Algorithm 3.2
        D = []
        print("  Checking number of ideals found...")
        for delta in ideals:
            if len(set(ideals[delta])) > 1:
                D.append(delta)
                
        
        print("    Done!")
        D = sorted(list(set(D)),reverse=True)
        print("  Returning "+str(len(D))+" discriminants with "+str(p)+"-rank > 1")
        print("")
        return(D)
    
    if p > 3 or force_3==True:
        
        if p==3 and force_3==True:
            print("  Forcing ideal independence testing for p=3")
        print("  Searching for solutions/ generating ideals...")
        ideals = {}
    
        for (lambda1, lambda2) in lambdas:
            for m1 in range(lower_m1, upper_m1 + 1):

                for m2 in range(2, m1):

                    N = 4*lambda2^2*m1^p - 4*lambda1^2*m2^p
                    if N == 0:
                        continue 
                    sqN = sqrt(abs(N))
                    for a in divisors(N):
                        if a <= sqN:
                            b = N/a
                            if (2*lambda2).divides(a+b):

                                y1 = (a+b)/(2*lambda2)

                                ideal_1 = Solution_to_Ideals(p, y1, m1) # carries out lines 11-22 in Algorithm 3.4

                                # if all of the "if" statements between lines 11-22 in Algorithm 3.4 have passed, 
                                  # we now carry out line 23. 
                                if ideal_1[0]: 
                                    delta = ideal_1[1]
                                    if delta in ideals:
                                        ideals[delta].append(ideal_1[2])
                                    else:
                                        ideals[delta] = [ideal_1[2]]


                            if (2*lambda1).divides(a-b):
                                y2 = (a-b)/(2*lambda1)

                                ideal_2 = Solution_to_Ideals(p, y2, m2) # carries out line 26 in Algorithm 3.2

                                if ideal_2[0]:
                                    delta = ideal_2[1]
                                    if delta in ideals:
                                        ideals[delta].append(ideal_2[2])
                                    else:
                                        ideals[delta] = [ideal_2[2]]







        print("    Done!")

        print("  Starting independence testing...")

        # the following carries out lines 27-32 in Algorithm 3.2
       
        D = []
        for delta in ideals:
            if rankcheck(p, ideals[delta]):
                D.append(delta)
       
        

        print("    Done!")
        D = sorted(list(set(D)),reverse=True)
        print("  Returning "+str(len(D))+" discriminants with "+str(p)+"-rank > 1")
        print("")
        return(D)
    
    
    
    
    
    

# Solution_to_Ideals carries out lines 11-22 in Algorithm 3.2, and also carries out the ideas described in Theorem 2.4. 
    # it returns the ideal as described in line 19 as a list of coefficients [A,B,C] of a binary quadratic form. 
    # If any of the "if" statements are not satisfied, it simply returns a list containing False. 
def Solution_to_Ideals(p, y, m):
    t = ZZ(y^2 - 4*m^p)
    if t < 0:
        delta = t.squarefree_part()

        if delta % 4 != 1:
            delta = 4*delta
        if delta.divides(t):
            z = ZZ(sqrt(t/delta))
            c = ZZ(gcd(m, z))
            if c.divides(delta) and not 4.divides(c):
                    
               #the following carries out the ideas described in Theorem 2.4    
            
                if 4.divides(delta):
                    e = 0
                else:
                    e = 1
                z_prime = Integer(z//(c^((p-1)/2)))
                y_prime = Integer(y//(c^((p-1)/2)))
                if z_prime % 2 == 1:
                    bezout = xgcd(4*m, z_prime)
                    z_star = bezout[2]
                    x = (z_star*y_prime) % (4*m)  

                else:
                    bezout = xgcd(m, z_prime)
                    z_star = bezout[2]

                    x = crt(z_star*y_prime, e , m, 4)

                t = (x-e)//2

                if t < m:
                    A = m
                    B = x
                    C = (B^2 - delta)//(4*A)
                else:
                    A = m
                    B = x - 2*m
                    C = (B^2 - delta)//(4*A)

                
                return([True, delta, [A, B, C]])
            
    return([False])









# rankcheck takes in a list of coefficients, corresponding to binary quadratic forms, and returns True if  
    # these forms generate a subgroup of order at least p^2 in the class group. This function makes use of Sage's 
    # BinaryQF package 
def rankcheck(p, forms_coeffs):
    
    
    forms = []
    for coeff in forms_coeffs:
        
        # convert coefficients to binary quadratic forms using Sage's built in BinaryQF
        Qform = BinaryQF([coeff[0], coeff[1], coeff[2]]).reduced_form() 
        if Qform not in forms:
            forms.append(Qform)
    
    # full generated will contain the subgroup generated by the forms 
    full_generated = []

    counter = 0

    while counter < len(forms):


        if counter == 0:
            
            # the following adds powers of the first form to the subgroup
            f = forms[counter]
            f1 = f
            full_generated.append(f)
            counter = counter+1

            for power in range(1, p):
                f = (f*f1).reduced_form()
                full_generated.append(f)
            
        else:


            f = forms[counter] 
            counter += 1
            if f in full_generated:
                continue 

            # the following puts powers of the next forms into current_subgroup 
            current_subgroup = []
            f1 = f
            current_subgroup.append(f)
            for power in range(1, p):
                f = (f*f1).reduced_form()
                current_subgroup.append(f)

            # the product of current_subgroup and full_generated is taken and replaces full_generated
            new_generated = set()
            for element in itertools.product(current_subgroup, full_generated):
                new  = (numpy.prod(element)).reduced_form()
                new_generated.add(new)
            full_generated = list(new_generated)
            
            
            if len(full_generated) > p: #if the forms generate a subgroup of size larger than p, then we can conclude k > 1. 
    
                return(True)

    # return False if the forms do not generate a large enough subgroup.       
    return(False)


###############################################################
###############################################################
###############################################################

# TO RUN: 
    # Save this file with a .sage extension, run in Sage v9.2. 
    
# The function Alg_3_2(p, lambdas, lower_m1, upper_m1, force_3=False) should be run with desired parameters, 
    # with parameters as defined above. 
# For example, 

# Alg_3_2(3 ,[(1, 1),(2, 1)], 3, 100)

# runs this with p=3, over the lambda_pairs (1,1) and (2,2), with a search with 3 <= m_1 <= 100. 
# Although, this will not save the returned list of discriminants, so perhaps it should be run as 

# disc_list_1 = Alg_3_2(3 ,[(1, 1),(2, 1)], 3, 100)

# and then the list of discriminants can be saved/ printed as desired. 

# By default, this does not perform explicit ideal independence testing for p=3, but this could be forced with 

# disc_list_2 = Alg_3_2(3 ,[(1, 1),(2, 1)], 3, 100, True)

# This is typically not worth the trade-off of increased runtime. 
# Also, this flag will not affect anything if p > 3. For example, the following are identical

# disc_list_3 = Alg_3_2(5 ,[(1, 1),(2, 1), (3,1)], 3, 100)
# disc_list_4 = Alg_3_2(5 ,[(1, 1),(2, 1), (3,1)], 3, 100, True)

# as a default, this file runs 
D = Alg_3_2(7 ,[(1, 1),(2, 1), (3,1)], 3, 64)

