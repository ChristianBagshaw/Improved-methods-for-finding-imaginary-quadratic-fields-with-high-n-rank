# Factoring Sieve as in Algorithm 3.1

# Input:
  # Odd prime: "p"
  # A fixed integer: "m1"
  # Largest prime to sieve over: "sieve_bound"
  # Integer pair: "(lambda1, lambda2)"
#Output:
  # An arrary consisting of small prime factors of 4*lambda1^2*m1^p - 4*lambda2^2*m2^p for pairs (m1, 2), ..., (m1, m1-1): "factor_array"


# "roots_generate" is called upon by "Fac_Sieve", and produces a dictionary containing, for each prime q up to "sieve_bound", the roots of x^p - (lambda2/lambda1) = 0 mod q. 

def roots_generate(p, sieve_bound, lambda1, lambda2):
    roots = {}
    for q in prime_range(2, roots_bound+1):
        Zq = Integers(q)  # Zq is the ring of integers modulo q, Z/qZ
        if not q.divides(lambda1):
            lambda1inv = inverse_mod(lambda1, q)
        else:
            continue
        roots[q] =  Zq((lambda2*lambda1inv)^2).nth_root(p, all=True)  # computes the roots of x^p - (lambda2/lambda1)^2 = 0 mod q
    return(roots)



def Fac_Sieve(p, m1, sieve_bound, lambda1, lambda2):
    factor_array = [[] for m2 in range(0, m1)]
    roots = roots_generate(p, sieve_bound, lambda1, lambda2)
    for q in roots:
          for x in roots[q]:
              xm1 = (x*m1)%q
              for m2 in range (xm1, m1, q):
                  factor_array[m2].append(q)
    return(factor_array)
