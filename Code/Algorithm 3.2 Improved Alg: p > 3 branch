# Algorithm 3.2 Improved Alg, p > 3 branch

# Algorithm 3.1 uses two slightly different ideas, depending on whether p=3 or p > 3. 
  # THIS FILE CORRESPONDS TO p > 3, although it will work for p=3 (it will simply be less than optimal). 



# This algorithm has been split into three functions, but calling upon Explicit_Ind will run all of Algorithm 3.2.  
  # That is, Explicit_Ind encompasses Algorithm 3.2 and calls upon the other two functions here. 
    
    
# We keep in mind that when dealing with ideals in a quadratic number field, it is equivalent to look at binary quadratic forms. 
    # Thus, we work with Sage's BinaryQF package.
    
    
# Memory will quickly become an issue if this code is run verbatim for a large computation, since 
    # a lot of data is being stored in dictionaries. In a large computation, this data 
    # should be stored outside of memory. 
  
  
    



# Input
    # Odd prime: "p"
    # Set of integer pairs {(lambda_i1, lambda_i2): "lambdas"
    # Lower bound on m_1: "lower_m1"
    # Upper bound on m_1: "upper_m1"
#Output
    # A list, "D", consisting of discriminants, each corresponding to a non-empty set of triples 
        # {(m_i, y_i, (lambda_ij)*z_i)} satisfying Proposition (2.3) (a) for n=p with 
        # lower_m1 <= m_1 <= upper_m1 and 2 <= m_2 < m_1, such that the ideal classes corresponding to the triples 
        # {(m_i, y_i, (lambda_ij)z_i)} generate a subgroup of the ideal class group of 
        # Q(sqrt{delta}) isomorphic to (Z/pZ)^k for some k > 1. 
        

from math import sqrt
import itertools
import numpy 
       
    
def Explicit_Ind(p, lambdas, lower_m1, upper_m1):
    print("Running Algorithm 3.3/ Exp Search for")
    print("p= "+str(p)+", lambdas = "+str(lambdas)+", lower_m1 = "+str(lower_m1)+", upper_m1 = "+str(upper_m1))
    
    ideals = {}
    
    for (lambda1, lambda2) in lambdas:
        for m1 in range(lower_m1, upper_m1 + 1):

            for m2 in range(2, m1):

                N = 4*lambda2^2*m1^p - 4*lambda1^2*m2^p
                if N < 0:
                    continue 
                sqN = sqrt(N)
                for a in divisors(N):
                    if a <= sqN:
                        b = N/a
                        if (2*lambda2).divides(a+b):

                            y1 = (a+b)/(2*lambda2)

                            ideal_1 = Solution_to_Ideals(p, y1, m1) # carries out lines 11-22 in Algorithm 3.4
                            
                            # if all of the "if" statements between lines 11-22 in Algorithm 3.4 have passed, 
                              # we now carry out line 23. 
                            if ideal_1[0]: # checks if 
                                delta = ideal_1[1]
                                if delta in ideals:
                                    ideals[delta].append(ideal_1[2])
                                else:
                                    ideals[delta] = [ideal_1[2]]


                        if (2*lambda1).divides(a-b):
                            y2 = (a-b)/(2*lambda1)

                            ideal_2 = Solution_to_Ideals(p, y2, m2) # carries out line 26 in Algorithm 3.2

                            if ideal_2[0]:
                                delta = ideal_2[1]
                                if delta in ideals:
                                    ideals[delta].append(ideal_2[2])
                                else:
                                    ideals[delta] = [ideal_2[2]]

                        
                    
   
                                                
           
    
    print("Done generating ideals")
    
    print("Starting independence testing...")
    
    # the following carries out lines 27-32 in Algorithm 3.2
    D = []
    for delta in ideals:
        if rankcheck(p, ideals[delta]):
            D.append(delta)
       
        
    print("Done generating ideals")
    
    return(D)
    
    

# Solution_to_Ideals carries out lines 11-22 in Algorithm 3.2, and also carries out the ideas described in Theorem 2.4. 
    # it returns the ideal as described in line 19 as a list of coefficients [A,B,C] of a binary quadratic form. 
    # If any of the "if" statements are not satisfied, it simply returns a list containing False. 
def Solution_to_Ideals(p, y, m):
    t = ZZ(y^2 - 4*m^p)
    if t < 0:
        delta = t.squarefree_part()
        if delta % 4 != 1:
            delta = 4*delta
        if delta.divides(t):
            z = ZZ(sqrt(t/delta))
            c = ZZ(gcd(m, z))
            if c.divides(delta) and not 4.divides(c):
                    
               #the following carries out the ideas described in Theorem 2.4    
            
                if 4.divides(delta):
                    e = 0
                else:
                    e = 1
                z_prime = Integer(z//(c^((p-1)/2)))
                y_prime = Integer(y//(c^((p-1)/2)))
                if z_prime % 2 == 1:
                    bezout = xgcd(4*m, z_prime)
                    z_star = bezout[2]
                    x = (z_star*y_prime) % (4*m)  

                else:
                    bezout = xgcd(m, z_prime)
                    z_star = bezout[2]

                    x = crt(z_star*y_prime, e , m, 4)

                t = (x-e)//2

                if t < m:
                    A = m
                    B = x
                    C = (B^2 - delta)//(4*A)
                else:
                    A = m
                    B = x - 2*m
                    C = (B^2 - delta)//(4*A)

           
                return([True, delta, [A, B, C]])
            
    return([False])


               

# rankcheck takes in a list of coefficients, corresponding to binary quadratic forms, and returns True if  
    # these forms generate a subgroup of order at least p^2 in the class group. This function makes use of Sage's 
    # BinaryQF package
    
    
def rankcheck(p, forms_coeffs):
    
    forms = []
    for coeff in forms_coeffs:
        
        # convert coefficients to binary quadratic forms using Sage's built in BinaryQF
        Qform = BinaryQF([coeff[0], coeff[1], coeff[2]]).reduced_form() 
        if Qform not in forms:
            forms.append(Qform)
    
    # full generated will contain the subgroup generated by the forms 
    full_generated = []

    counter = 0

    while counter < len(forms) - 1:


        if counter == 0:
            
            # the following adds powers of the first form to the subgroup
            f = forms[counter]
            f1 = f
            full_generated.append(f)
            counter = counter+1

            for power in range(1, p):
                f = (f*f1).reduced_form()
                full_generated.append(f)

        else:


            f = forms[counter] 
            if f in full_generated:
                counter += 1
                continue 

            # the following puts powers of the next forms into current_subgroup 
            current_subgroup = []
            f = forms[counter]
            counter = counter+1
            f1 = f
            current_subgroup.append(f)
            for power in range(1, p):
                f = (f*f1).reduced_form()
                current_subgroup.append(f)

            # the product of current_subgroup and full_generated is taken and replaces full_generated
            new_generated = set()
            for element in itertools.product(current_subgroup, full_generated):
                new  = (numpy.prod(element)).reduced_form()
                new_generated.add(new)
            full_generated = list(new_generated)
            
            if len(full_generated) > p: #if the forms generate a subgroup of size larger than p, then we can conclude k > 1. 
              return(True)

    # return False if the forms do not generate a large enough subgroup.       
    return(False)


    
  
    
    
   
