# Factoring Sieve as in Algorithm 3.1

# This file simply serves to isolate the factoring sieve algorithm. 

# To TEST/ RUN:
    # View bottom of file. 
    # Save file with a .sage extension, and run in Sage v9.2. 

# Input:
  # Odd prime: "p"
  # A fixed integer: "m1"
  # Largest prime to sieve over: "sieve_bound"
  # Integer pair: "(lambda1, lambda2)"
#Output:
  # An arrary consisting of small prime factors of 4*lambda1^2*m1^p - 4*lambda2^2*m2^p for pairs (m1, 2), ..., (m1, m1-1): "factor_array"


# "roots_generate" is called upon by "Fac_Sieve", and produces a dictionary containing, for each prime q up to "sieve_bound", the roots of x^p - (lambda2/lambda1) = 0 mod q. 

def roots_generate(p, sieve_bound, lambda1, lambda2):
    roots = {}
    for q in prime_range(2, sieve_bound+1):
        Zq = Integers(q)  # Zq is the ring of integers modulo q, Z/qZ
        if not q.divides(lambda1):
            lambda1inv = inverse_mod(lambda1, q)
        else:
            continue
        roots[q] =  Zq((lambda2*lambda1inv)^2).nth_root(p, all=True)  # computes the roots of x^p - (lambda2/lambda1)^2 = 0 mod q
    return(roots)



def Fac_Sieve(p, m1, sieve_bound, lambda1, lambda2):
    factor_array = [[] for m2 in range(0, m1)]
    roots = roots_generate(p, sieve_bound, lambda1, lambda2)
    for q in roots:
          for x in roots[q]:
              xm1 = (x*m1)%q
              for m2 in range (xm1, m1, q):
                  factor_array[m2].append(q)
    return(factor_array)




############################
############################


# TO RUN: 
    # Save this file with a .sage extension, run in Sage v9.2. 

# The prompts below will run the function above

print("Running Dyd Ext")
print("  Input value for p")
p = int(input("    p = "))
print("  Input m_1")
m1 = int(input("    m_1 = "))
print("  Input sieve bound")
sieve_bound = int(input("    sieve bound = "))
print("  Input lambda1")
lambda1 = int(input("    lambda1 = "))
print("  Input lambda2")
lambda2 = int(input("    lambda2 = "))
print("")

A = Fac_Sieve(p, m1, sieve_bound, lambda1, lambda2)
print(A)

